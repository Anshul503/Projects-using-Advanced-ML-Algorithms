# -*- coding: utf-8 -*-
"""
Created on Thu Jul  9 13:02:45 2020

@author: ANSHUL
"""


# -*- coding: utf-8 -*-
"""SOM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qd72k2xntZ0F49e8zn4ox9IOZcnWwTBk

#Self Organizing Map

##Install MiniSom Package
"""

# pip install MiniSom  # Why to install Minisome (see once ???)

"""### Importing the libraries"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

"""## Importing the dataset"""

dataset = pd.read_csv('Credit_Card_Applications.csv')
X = dataset.iloc[:, :-1].values 
y = dataset.iloc[:, -1].values

"""## Feature Scaling"""

from sklearn.preprocessing import MinMaxScaler
sc = MinMaxScaler(feature_range = (0,1))
X = sc.fit_transform(X)  # fit is used to do FS and transform to apply transformation (see once ???)

"""##Training the SOM"""

from minisom import MiniSom # Minisom is used to implement Self Organised Map(SOM)
som = MiniSom(x=10, y=10, input_len= 15, sigma= 1.0, learning_rate = 0.5) # 1st argument is the grid which it will take for each row. 3rd parameter is no. of independent features and i this we want customer id too,so that we can identify with the id who will cheat. Sigma correspond to radius of circle (particular observation per row).The more the learning rate, the better will be the prediction,i.e cost function in min. iteration
som.random_weights_init(X) #initalise with some random weight(close to 0). Here, we don't have any Activation Function unlike in deep supervised learning (VVV IMP)
som.train_random(data = X, num_iteration = 100) #iteration means epoch,over per row.On every iteration the circle of each observation gets reduced (IMP)
  # Now it has identified the pattern 
"""##Visualizing the results"""

from pylab import bone, pcolor, colorbar, plot, show # we are doing this as it is not simple graph
bone() # this generate empty map
pcolor(som.distance_map().T) # it will generate MID(Mean Interneuron Distance) and then Transposing that matrix by (.T) 
colorbar() # here it gives MID value color,white correspond to highest MID and For black it is vice versa 
markers = ['o', 's'] # o for circle and s for square
colors = ['r', 'g'] # r for red(who didn't got approval) and green for those who got approval
for i, x in enumerate(X): # i correspond to difft. customers and x correspond to fetaures of customer in dataset.See once this for loop (ask once ???)
    w = som.winner(x) #  Taking every customer 
    plot(w[0] + 0.5,  # we are centering the position in the square 
         w[1] + 0.5, # agar MID zyada hai toh more chances it is outlier 
         markers[y[i]], # us particular customer ke liye dekh rha,ye dependent variable se measure kar rha jo Y hai
         markeredgecolor = colors[y[i]], #ye jo marker and colors hai wo Y(dependent variable) se dekh ke bta rha
         markerfacecolor = 'None', # face color correspond to inside color in marker,
         markersize = 10,
         markeredgewidth = 2)
show()

"""## Finding the frauds"""

mappings = som.win_map(X)
frauds = np.concatenate((mappings[(8,1)], mappings[(6,8)]), axis = 0) #  mapping is the coordinate corespond to white boxes
frauds = sc.inverse_transform(frauds) # (1,1) and (4,1) were initial values (see once ???)

"""##Printing the Fraunch Clients"""

print('Fraud Customer IDs')
for i in frauds[:, 0]:# humara mod
  print(int(i)) # yaha kuch bank waalo ne pakda but un logo ko jinko approval de diya but nhi dena chahiye tha, is what our model is predicting